from dataclasses import dataclass
from datetime import datetime
from typing import Literal, Union
import threading



class SapphireEvents():

	@dataclass(frozen = True)
	class Chain():
		context: int
		flow: int

		def __str__(self) -> str:
			return f"({self.context}:{self.flow})"
		
		def __eq__(self, other) -> bool:
			return (self.context, self.flow) == (other.context, other.flow)
		

	_lock = threading.Lock()
	_intern_chain = Chain(0, 0)
	_current_context = 0

	@classmethod
	def chain(cls, event: Union["Event", None] = None) -> Chain:
		"Class Method to chain events. If empty, returns a new chain."
		if isinstance(event, cls.Event):
			return event.chain
		else:
			chain = cls._intern_chain
			with cls._lock: 
				cls._intern_chain = SapphireEvents.Chain(
					0,
					chain.flow + 1
				)
			return chain
		
		
	@classmethod
	def new_context_chain(cls) -> Chain:
		"Method for getting a chain with a new context."
		with cls._lock: cls._current_context += 1
		chain = SapphireEvents.Chain(
			cls._current_context, 0
		)
		return chain
	

	@classmethod
	def make_timestamp(cls):
		"Class method for giving a standard timestamp format for all events."
		return datetime.now().strftime("%H:%M:%S")
			

	_intern_map: dict[str, type["Event"]] = {}
	@classmethod
	def serialize(cls, event: str) -> type["Event"]:
		"Method for getting an event class using its name. Will raise an exception on invalid values."

		if not cls._intern_map:
			for name, attr in SapphireEvents.__dict__.items():
				if issubclass(attr, SapphireEvents.Event):
					cls._intern_map[name] = attr

		if event not in cls._intern_map:
			raise ValueError(f"Unknown event: {event}")
		return cls._intern_map[event]
		


	@dataclass
	class Event():
		"Base event class."
		sender: str
		timestamp: str
		chain: "SapphireEvents.Chain"


	@dataclass
	class LogEvent(Event):
		"Event that the logger module listens for."
		level: Literal["debug", "info", "warning", "critical"]
		message: str


	@dataclass
	class ShutdownEvent(Event):
		"Sent to core to intiate a shutdown."
		emergency: bool
		situation: Literal["request", "failure", "critical", "user"]


	@dataclass
	class UserInputEvent(Event):
		"All user messages are sent using this event."
		message: str


	@dataclass
	class CommandEvent(Event):
		"Command that the core can execute."
		cmd: str
		args: list[str]


	@dataclass
	class CommandExecutedEvent(Event):
		"The output of an executed command."
		cmd: tuple[str, list[str]]
		success: bool
		output: str


	@dataclass
	class ConfirmationEvent(Event):
		"Used for confirmation with the user."
		message: str
		options: list[str]
		selected: str | None


	@dataclass
	class ErrorEvent(Event):
		"In case something goes wrong."
		error: str
		message = str 


	@dataclass
	class PromptEvent(Event):
		"Event passed by the prompt manager after it assembles the prompt"
		content: str


	@dataclass
	class AIResponseEvent(Event):
		"The response generated by the AI model."
		message: dict[str, str]
		tasks: list[tuple[str, dict[str, str]]]

	
	@dataclass
	class ClientActivationEvent(Event):
		"The first event passed by the server to the client so it can initialize its chain."
		message: str


